import { useState, useEffect, useRef, useCallback } from 'react';
import { useParams, useSearchParams, useNavigate } from 'react-router-dom';
import { useMutation, useQuery } from '@tanstack/react-query';
import api from '../../lib/api';
import { toast } from 'react-hot-toast';
import Video, { Room, LocalVideoTrack, LocalAudioTrack, RemoteParticipant, RemoteTrack, RemoteTrackPublication } from 'twilio-video';
import VideoControls from '../../components/Telehealth/VideoControls';
import TranscriptionPanel from '../../components/Telehealth/TranscriptionPanel';
import { X, Maximize2, Minimize2, FileText } from 'lucide-react';

interface TelehealthSession {
  id: string;
  appointmentId: string;
  chimeMeetingId: string; // Actually stores Twilio Room SID
  clinicianJoinUrl: string;
  clientJoinUrl: string;
  meetingDataJson: any;
  status: string;
  sessionStartedAt?: string;
  sessionEndedAt?: string;
  appointment?: {
    client?: {
      firstName: string;
      lastName: string;
    };
    clinician?: {
      firstName: string;
      lastName: string;
      title: string;
    };
  };
}

interface EmergencyContact {
  name: string;
  phone: string;
  relationship: string;
}

export default function VideoSession() {
  const { appointmentId } = useParams<{ appointmentId: string }>();
  const [searchParams] = useSearchParams();
  const userRole = searchParams.get('role') || 'clinician'; // clinician or client
  const navigate = useNavigate();

  // Check if appointmentId is valid UUID
  const isValidAppointmentId = appointmentId && appointmentId !== '{appointmentId}' &&
    /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(appointmentId);

  const [room, setRoom] = useState<Room | null>(null);
  const [isAudioMuted, setIsAudioMuted] = useState(false);
  const [isVideoOff, setIsVideoOff] = useState(false);
  const [isScreenSharing, setIsScreenSharing] = useState(false);
  const [sessionStatus, setSessionStatus] = useState<'loading' | 'waiting' | 'connecting' | 'connected' | 'reconnecting' | 'ended'>('loading');
  const [sessionDuration, setSessionDuration] = useState(0);
  const [networkQuality, setNetworkQuality] = useState<'good' | 'fair' | 'poor'>('good');
  const [devicePermissionsGranted, setDevicePermissionsGranted] = useState(false);
  const [remoteParticipantCount, setRemoteParticipantCount] = useState(0);
  const [isRecording, setIsRecording] = useState(false);
  const [showTranscript, setShowTranscript] = useState(false);
  const [emergencyContact, setEmergencyContact] = useState<EmergencyContact | undefined>(undefined);

  const localVideoRef = useRef<HTMLVideoElement>(null);
  const remoteVideoRef = useRef<HTMLVideoElement>(null);
  const screenShareRef = useRef<HTMLVideoElement>(null);
  const sessionStartTimeRef = useRef<number | null>(null);
  const durationIntervalRef = useRef<NodeJS.Timeout | null>(null);
  const localVideoTrackRef = useRef<LocalVideoTrack | null>(null);
  const localAudioTrackRef = useRef<LocalAudioTrack | null>(null);
  const screenShareTrackRef = useRef<any>(null);

  // Fetch session details
  const { data: sessionData, isLoading, refetch } = useQuery({
    queryKey: ['telehealth-session', appointmentId],
    queryFn: async () => {
      try {
        const response = await api.get(`/telehealth/sessions/${appointmentId}`);
        return response.data.data as TelehealthSession;
      } catch (error: any) {
        // If session doesn't exist (404), create it automatically
        if (error.response?.status === 404) {
          console.log('Session not found, creating new session...');
          const createResponse = await api.post('/telehealth/sessions', { appointmentId });
          return createResponse.data.data as TelehealthSession;
        }
        throw error;
      }
    },
    enabled: !!isValidAppointmentId,
    refetchInterval: 10000, // Refetch every 10 seconds to check session status
  });

  // Fetch emergency contact when session is connected
  const { data: emergencyContactData } = useQuery({
    queryKey: ['emergency-contact', sessionData?.id],
    queryFn: async () => {
      if (!sessionData?.id) return null;
      try {
        const response = await api.get(`/telehealth/sessions/${sessionData.id}/emergency-contact`);
        return response.data.data as EmergencyContact | null;
      } catch (error: any) {
        console.warn('Failed to fetch emergency contact:', error);
        return null;
      }
    },
    enabled: !!sessionData?.id && userRole === 'clinician',
  });

  useEffect(() => {
    if (emergencyContactData) {
      setEmergencyContact(emergencyContactData);
    }
  }, [emergencyContactData]);

  // Join session mutation
  const joinMutation = useMutation({
    mutationFn: async () => {
      const response = await api.post('/telehealth/sessions/join', {
        appointmentId,
        userRole,
      });
      return response.data.data;
    },
    onSuccess: async (data) => {
      toast.success('Joining session...');
      await initializeTwilioSession(data);
    },
    onError: (error: any) => {
      toast.error(error.response?.data?.message || 'Failed to join session');
      setSessionStatus('ended');
    },
  });

  // End session mutation
  const endMutation = useMutation({
    mutationFn: async () => {
      if (sessionData?.id) {
        await api.post('/telehealth/sessions/end', {
          sessionId: sessionData.id,
          endReason: 'Normal',
        });
      }
    },
    onSuccess: () => {
      toast.success('Session ended');
      cleanupTwilioSession();
      navigate('/appointments');
    },
  });

  // Recording mutations (using legacy endpoints)
  const startRecordingMutation = useMutation({
    mutationFn: async (consent: boolean) => {
      if (!sessionData?.id) throw new Error('Session not found');
      const response = await api.post('/telehealth/sessions/recording/start', {
        sessionId: sessionData.id,
        consent: consent,
      });
      return response.data.data;
    },
    onSuccess: () => {
      setIsRecording(true);
      toast.success('Recording started');
    },
    onError: (error: any) => {
      toast.error(error.response?.data?.message || 'Failed to start recording');
    },
  });

  const stopRecordingMutation = useMutation({
    mutationFn: async () => {
      if (!sessionData?.id) throw new Error('Session not found');
      await api.post(`/telehealth/sessions/recording/stop/${sessionData.id}`);
    },
    onSuccess: () => {
      setIsRecording(false);
      toast.success('Recording stopped');
    },
    onError: (error: any) => {
      toast.error(error.response?.data?.message || 'Failed to stop recording');
    },
  });

  // Emergency activation mutation
  const emergencyMutation = useMutation({
    mutationFn: async (data: {
      emergencyNotes: string;
      emergencyResolution: 'CONTINUED' | 'ENDED_IMMEDIATELY' | 'FALSE_ALARM';
      emergencyContactNotified: boolean;
    }) => {
      if (!sessionData?.id) throw new Error('Session not found');
      await api.post('/telehealth/sessions/emergency', {
        sessionId: sessionData.id,
        ...data,
      });
    },
    onSuccess: () => {
      toast.success('Emergency protocol activated and documented');
    },
    onError: (error: any) => {
      toast.error(error.response?.data?.message || 'Failed to activate emergency protocol');
    },
  });

  // Request device permissions
  const requestDevicePermissions = async () => {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
      stream.getTracks().forEach(track => track.stop()); // Stop the stream after getting permission
      setDevicePermissionsGranted(true);
      return true;
    } catch (error) {
      console.error('Failed to get device permissions:', error);
      toast.error('Please allow camera and microphone access to join the session');
      return false;
    }
  };

  // Initialize Twilio Video session
  const initializeTwilioSession = async (joinData: any) => {
    try {
      setSessionStatus('connecting');

      // Request permissions first
      const permissionsGranted = await requestDevicePermissions();
      if (!permissionsGranted) {
        setSessionStatus('ended');
        return;
      }

      // Get Twilio token and room name from backend response
      const { twilioToken, twilioRoomName } = joinData;

      console.log('Connecting to Twilio room:', twilioRoomName);

      // Check if this is a mock session (offline mode)
      const isMockMode = twilioToken?.startsWith('MOCK_TOKEN_');

      if (isMockMode) {
        console.warn('‚ö†Ô∏è MOCK MODE: Twilio unavailable - using simulated video session');
        toast('Demo Mode: Twilio service unavailable', { icon: '‚ö†Ô∏è' });

        // Create local tracks for preview
        try {
          const localVideoTrack = await Video.createLocalVideoTrack({
            width: 1280,
            height: 720,
            frameRate: 24,
          });
          const localAudioTrack = await Video.createLocalAudioTrack();

          localVideoTrackRef.current = localVideoTrack;
          localAudioTrackRef.current = localAudioTrack;

          // Attach local video to video element
          if (localVideoRef.current) {
            localVideoTrack.attach(localVideoRef.current);
          }
        } catch (error) {
          console.error('Failed to create local tracks:', error);
        }

        // Simulate connection success
        setSessionStatus('connected');
        toast.success('Connected to demo session');

        // Start session timer
        sessionStartTimeRef.current = Date.now();
        durationIntervalRef.current = setInterval(() => {
          if (sessionStartTimeRef.current) {
            setSessionDuration(Math.floor((Date.now() - sessionStartTimeRef.current) / 1000));
          }
        }, 1000);

        setRemoteParticipantCount(0);
        setNetworkQuality('good');

        console.log('‚úÖ Mock session initialized - video UI will work without remote connection');
        return;
      }

      // Create local tracks
      const localVideoTrack = await Video.createLocalVideoTrack({
        width: 1280,
        height: 720,
        frameRate: 24,
      });
      const localAudioTrack = await Video.createLocalAudioTrack();

      localVideoTrackRef.current = localVideoTrack;
      localAudioTrackRef.current = localAudioTrack;

      // Attach local video to video element
      if (localVideoRef.current) {
        localVideoTrack.attach(localVideoRef.current);
      }

      // Connect to Twilio room
      const twilioRoom = await Video.connect(twilioToken, {
        name: twilioRoomName,
        tracks: [localVideoTrack, localAudioTrack],
        networkQuality: {
          local: 1,
          remote: 1,
        },
        bandwidthProfile: {
          video: {
            mode: 'collaboration',
            maxSubscriptionBitrate: 2500000,
          },
        },
        maxAudioBitrate: 16000,
        preferredVideoCodecs: ['VP8'],
      });

      // CRITICAL FIX: Set room and status BEFORE setting up event listeners
      setRoom(twilioRoom);
      
      // Use setTimeout to ensure state updates are processed
      setTimeout(() => {
        setSessionStatus('connected');
        toast.success('Connected to session');
      }, 100);

      // Start session timer
      sessionStartTimeRef.current = Date.now();
      durationIntervalRef.current = setInterval(() => {
        if (sessionStartTimeRef.current) {
          setSessionDuration(Math.floor((Date.now() - sessionStartTimeRef.current) / 1000));
        }
      }, 1000);

      // Handle existing remote participants
      twilioRoom.participants.forEach(handleParticipantConnected);
      setRemoteParticipantCount(twilioRoom.participants.size);

      // Set up event listeners
      twilioRoom.on('participantConnected', (participant: RemoteParticipant) => {
        console.log('Participant connected:', participant.identity);
        handleParticipantConnected(participant);
        setRemoteParticipantCount(twilioRoom.participants.size);
        toast.success(`${participant.identity} joined the session`);
      });

      twilioRoom.on('participantDisconnected', (participant: RemoteParticipant) => {
        console.log('Participant disconnected:', participant.identity);
        handleParticipantDisconnected(participant);
        setRemoteParticipantCount(twilioRoom.participants.size);
        toast(`${participant.identity} left the session`, { icon: '‚ÑπÔ∏è' });
      });

      twilioRoom.on('reconnecting', (error: any) => {
        console.log('Reconnecting to room...', error);
        setSessionStatus('reconnecting');
        toast('Connection lost. Trying to reconnect...', { icon: '‚ö†Ô∏è' });
      });

      twilioRoom.on('reconnected', () => {
        console.log('Reconnected to room');
        setSessionStatus('connected');
        toast.success('Reconnected to session');
      });

      twilioRoom.on('disconnected', (room: Room, error: any) => {
        console.log('Disconnected from room', error);
        setSessionStatus('ended');
        if (error) {
          toast.error('Disconnected from session');
        } else {
          toast('Session has ended', { icon: '‚ÑπÔ∏è' });
        }
        cleanupTwilioSession();
      });

      // Monitor network quality
      twilioRoom.localParticipant.on('networkQualityLevelChanged', (networkQualityLevel: number) => {
        console.log('Network quality:', networkQualityLevel);
        if (networkQualityLevel >= 4) {
          setNetworkQuality('good');
        } else if (networkQualityLevel >= 2) {
          setNetworkQuality('fair');
        } else {
          setNetworkQuality('poor');
        }
      });

      console.log('Successfully connected to Twilio room');
    } catch (error: any) {
      console.error('Failed to initialize Twilio session:', error);
      toast.error(error.message || 'Failed to connect to session');
      setSessionStatus('ended');
    }
  };

  // Handle remote participant connected
  const handleParticipantConnected = (participant: RemoteParticipant) => {
    console.log('Setting up tracks for participant:', participant.identity);

    // Handle existing tracks
    participant.tracks.forEach((publication: RemoteTrackPublication) => {
      if (publication.track) {
        handleTrackSubscribed(publication.track);
      }
    });

    // Handle new tracks
    participant.on('trackSubscribed', handleTrackSubscribed);
    participant.on('trackUnsubscribed', handleTrackUnsubscribed);
  };

  // Handle remote participant disconnected
  const handleParticipantDisconnected = (participant: RemoteParticipant) => {
    console.log('Cleaning up tracks for participant:', participant.identity);
    participant.removeAllListeners();
  };

  // Handle track subscribed
  const handleTrackSubscribed = (track: RemoteTrack) => {
    console.log('Track subscribed:', track.kind, track.name);

    if (track.kind === 'video') {
      // Check if this is a screen share track
      if (track.name.includes('screen')) {
        if (screenShareRef.current) {
          track.attach(screenShareRef.current);
          setIsScreenSharing(true);
        }
      } else {
        // Regular video track
        if (remoteVideoRef.current) {
          track.attach(remoteVideoRef.current);
        }
      }
    } else if (track.kind === 'audio') {
      // Attach audio track (will play automatically)
      track.attach();
    }
  };

  // Handle track unsubscribed
  const handleTrackUnsubscribed = (track: RemoteTrack) => {
    console.log('Track unsubscribed:', track.kind);
    try {
      if (track.kind !== 'data' && 'detach' in track) {
        const detachedElements = (track as any).detach();
        if (Array.isArray(detachedElements)) {
          detachedElements.forEach((element: any) => element?.remove());
        }
      }
    } catch (error) {
      console.error('Error detaching track:', error);
    }

    if (track.kind === 'video' && track.name.includes('screen')) {
      setIsScreenSharing(false);
    }
  };

  // Cleanup Twilio session
  const cleanupTwilioSession = useCallback(() => {
    console.log('Cleaning up Twilio session');

    // Stop screen sharing if active
    if (screenShareTrackRef.current) {
      screenShareTrackRef.current.stop();
      screenShareTrackRef.current = null;
    }

    // Stop local tracks
    if (localVideoTrackRef.current) {
      localVideoTrackRef.current.stop();
      localVideoTrackRef.current = null;
    }
    if (localAudioTrackRef.current) {
      localAudioTrackRef.current.stop();
      localAudioTrackRef.current = null;
    }

    // Disconnect from room
    if (room) {
      room.disconnect();
      setRoom(null);
    }

    // Clear session timer
    if (durationIntervalRef.current) {
      clearInterval(durationIntervalRef.current);
      durationIntervalRef.current = null;
    }

    // Reset session state
    setSessionStatus('ended');
    setSessionDuration(0);
    sessionStartTimeRef.current = null;
    setRemoteParticipantCount(0);
  }, [room]);

  // Control handlers for VideoControls component
  const handleToggleMute = (muted: boolean) => {
    setIsAudioMuted(muted);
  };

  const handleToggleVideo = (videoOff: boolean) => {
    setIsVideoOff(videoOff);
  };

  const handleToggleScreenShare = (sharing: boolean) => {
    setIsScreenSharing(sharing);
  };

  const handleStartRecording = async (consent: boolean) => {
    await startRecordingMutation.mutateAsync(consent);
  };

  const handleStopRecording = async () => {
    await stopRecordingMutation.mutateAsync();
  };

  const handleEmergencyActivated = async (data: {
    emergencyNotes: string;
    emergencyResolution: 'CONTINUED' | 'ENDED_IMMEDIATELY' | 'FALSE_ALARM';
    emergencyContactNotified: boolean;
  }) => {
    await emergencyMutation.mutateAsync(data);
  };

  const handleEndSession = () => {
    if (window.confirm('Are you sure you want to end this session?')) {
      endMutation.mutate();
    }
  };

  // Format duration as MM:SS
  const formatDuration = (seconds: number): string => {
    const mins = Math.floor(seconds / 60);
    const secs = seconds % 60;
    return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
  };

  // Auto-join when component mounts
  useEffect(() => {
    // Only attempt to join once when session data is loaded
    if (appointmentId && !isLoading && sessionData && !room && sessionStatus === 'loading') {
      // Check if we're in waiting room
      if (sessionData.status === 'WAITING_ROOM' && userRole === 'client') {
        setSessionStatus('waiting');
        toast('Please wait for the clinician to start the session...', { icon: '‚è≥' });
      } else {
        // Auto-join the session
        console.log('Auto-joining telehealth session...', { appointmentId, sessionId: sessionData.id });
        joinMutation.mutate();
      }
    }
  }, [appointmentId, sessionData, isLoading, room, sessionStatus, userRole]);

  // Cleanup on unmount
  useEffect(() => {
    return () => {
      cleanupTwilioSession();
    };
  }, [cleanupTwilioSession]);

  // Invalid appointment ID
  if (!isValidAppointmentId) {
    return (
      <div className="min-h-screen bg-gradient-to-br from-purple-50 via-indigo-50 to-blue-50 flex items-center justify-center p-4">
        <div className="bg-white rounded-2xl shadow-2xl p-12 max-w-2xl text-center border-2 border-purple-200">
          <div className="text-6xl mb-6">‚ö†Ô∏è</div>
          <h2 className="text-3xl font-bold bg-gradient-to-r from-purple-600 to-indigo-600 bg-clip-text text-transparent mb-4">
            Invalid Appointment ID
          </h2>
          <p className="text-gray-600 mb-6">
            The appointment ID in the URL is not valid. You cannot access telehealth sessions directly by typing the URL.
          </p>
          <div className="bg-gradient-to-r from-blue-50 to-indigo-50 border-2 border-blue-200 rounded-xl p-6 mb-6 text-left">
            <h3 className="font-bold text-gray-800 mb-3">How to start a telehealth session:</h3>
            <ol className="list-decimal list-inside space-y-2 text-gray-700">
              <li>Go to the <strong>Appointments</strong> page</li>
              <li>Find an appointment with status <strong>Confirmed</strong>, <strong>Checked In</strong>, or <strong>In Session</strong></li>
              <li>Click the <strong>"Join Telehealth Session"</strong> button</li>
            </ol>
          </div>
          <button
            onClick={() => navigate('/appointments')}
            className="px-8 py-3 bg-gradient-to-r from-indigo-600 to-purple-600 hover:from-indigo-700 hover:to-purple-700 text-white rounded-xl font-semibold transition-all shadow-lg transform hover:scale-105"
          >
            Go to Appointments
          </button>
        </div>
      </div>
    );
  }

  if (isLoading) {
    return (
      <div className="min-h-screen bg-gradient-to-br from-purple-50 via-indigo-50 to-blue-50 flex items-center justify-center">
        <div className="text-center">
          <div className="animate-spin rounded-full h-16 w-16 border-4 border-purple-200 border-t-purple-600 mx-auto mb-4"></div>
          <p className="text-xl font-semibold bg-gradient-to-r from-purple-600 to-indigo-600 bg-clip-text text-transparent">
            Loading session...
          </p>
        </div>
      </div>
    );
  }

  // Waiting room UI for client
  if (sessionStatus === 'waiting') {
    return (
      <div className="min-h-screen bg-gradient-to-br from-purple-50 via-indigo-50 to-blue-50 flex items-center justify-center p-4">
        <div className="bg-white rounded-2xl shadow-2xl p-12 max-w-md text-center border-2 border-indigo-200">
          <div className="text-6xl mb-6 animate-bounce">‚è≥</div>
          <h2 className="text-3xl font-bold bg-gradient-to-r from-purple-600 to-indigo-600 bg-clip-text text-transparent mb-4">
            Waiting Room
          </h2>
          <p className="text-gray-600 mb-6">
            Please wait while the clinician prepares for your session. You'll be admitted shortly.
          </p>
          <div className="flex justify-center space-x-2 mb-8">
            <div className="w-3 h-3 bg-gradient-to-r from-purple-500 to-indigo-500 rounded-full animate-pulse"></div>
            <div className="w-3 h-3 bg-gradient-to-r from-purple-500 to-indigo-500 rounded-full animate-pulse" style={{ animationDelay: '0.2s' }}></div>
            <div className="w-3 h-3 bg-gradient-to-r from-purple-500 to-indigo-500 rounded-full animate-pulse" style={{ animationDelay: '0.4s' }}></div>
          </div>
          <button
            onClick={() => navigate('/appointments')}
            className="px-6 py-3 bg-gray-200 hover:bg-gray-300 rounded-xl font-semibold transition-all"
          >
            Cancel & Return to Appointments
          </button>
        </div>
      </div>
    );
  }

  // Show join button if session is loaded but not connected
  if (sessionData && !room && sessionStatus === 'loading' && !joinMutation.isPending) {
    const clientName = sessionData?.appointment?.client 
      ? `${sessionData.appointment.client.firstName} ${sessionData.appointment.client.lastName}`
      : 'Unknown Client';
    
    return (
      <div className="min-h-screen bg-gradient-to-br from-purple-50 via-indigo-50 to-blue-50 flex items-center justify-center p-4">
        <div className="bg-white rounded-2xl shadow-2xl p-12 max-w-md text-center border-2 border-purple-200">
          <div className="text-6xl mb-6">üìπ</div>
          <h2 className="text-3xl font-bold bg-gradient-to-r from-purple-600 to-indigo-600 bg-clip-text text-transparent mb-4">
            Ready to Join Session
          </h2>
          <p className="text-gray-600 mb-6">
            Session for <strong>{clientName}</strong> is ready. Click below to join.
          </p>
          <button
            onClick={() => joinMutation.mutate()}
            disabled={joinMutation.isPending}
            className="px-8 py-4 bg-gradient-to-r from-indigo-600 to-purple-600 hover:from-indigo-700 hover:to-purple-700 text-white rounded-xl font-semibold transition-all shadow-lg transform hover:scale-105 disabled:opacity-50 disabled:cursor-not-allowed flex items-center gap-3 mx-auto"
          >
            {joinMutation.isPending ? (
              <>
                <div className="animate-spin rounded-full h-5 w-5 border-2 border-white border-t-transparent"></div>
                <span>Joining...</span>
              </>
            ) : (
              <>
                <svg className="w-6 h-6" fill="currentColor" viewBox="0 0 20 20">
                  <path d="M2 6a2 2 0 012-2h6a2 2 0 012 2v8a2 2 0 01-2 2H4a2 2 0 01-2-2V6zM14.553 7.106A1 1 0 0014 8v4a1 1 0 00.553.894l2 1A1 1 0 0018 13V7a1 1 0 00-1.447-.894l-2 1z" />
                </svg>
                <span>Join Telehealth Session</span>
              </>
            )}
          </button>
          <button
            onClick={() => navigate('/appointments')}
            className="mt-4 px-6 py-2 text-gray-600 hover:text-gray-800 font-medium transition-colors"
          >
            Cancel & Return to Appointments
          </button>
        </div>
      </div>
    );
  }

  const clientName = sessionData?.appointment?.client 
    ? `${sessionData.appointment.client.firstName} ${sessionData.appointment.client.lastName}`
    : 'Unknown Client';

  return (
    <div className="min-h-screen bg-black flex flex-col relative">
      {/* Header */}
      <div className="bg-gradient-to-r from-indigo-600 via-purple-600 to-pink-600 text-white p-4 flex items-center justify-between shadow-xl z-20">
        <div className="flex items-center space-x-6">
          <div>
            <h1 className="text-xl font-bold">Telehealth Session</h1>
            <p className="text-sm opacity-90">
              {clientName}
            </p>
          </div>
          {/* Session Timer */}
          {(sessionStatus === 'connected' || sessionStatus === 'reconnecting') && (
            <div className="flex items-center space-x-2 text-sm bg-white bg-opacity-20 backdrop-blur-sm px-4 py-2 rounded-xl border border-white border-opacity-30">
              <svg className="w-5 h-5" fill="currentColor" viewBox="0 0 20 20">
                <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm1-12a1 1 0 10-2 0v4a1 1 0 00.293.707l2.828 2.829a1 1 0 101.415-1.415L11 9.586V6z" clipRule="evenodd" />
              </svg>
              <span className="font-mono font-bold text-lg">{formatDuration(sessionDuration)}</span>
            </div>
          )}
        </div>
        <div className="flex items-center space-x-4">
          {/* Network Quality Indicator */}
          {(sessionStatus === 'connected' || sessionStatus === 'reconnecting') && (
            <div className="flex items-center space-x-2 bg-white bg-opacity-20 backdrop-blur-sm px-4 py-2 rounded-xl border border-white border-opacity-30">
              <div className="flex space-x-1">
                <div className={`w-2 h-4 ${networkQuality === 'poor' ? 'bg-red-400' : 'bg-green-400'} rounded`}></div>
                <div className={`w-2 h-5 ${networkQuality === 'good' || networkQuality === 'fair' ? 'bg-green-400' : 'bg-gray-400'} rounded`}></div>
                <div className={`w-2 h-6 ${networkQuality === 'good' ? 'bg-green-400' : 'bg-gray-400'} rounded`}></div>
              </div>
              <span className="text-sm font-semibold capitalize">{networkQuality}</span>
            </div>
          )}

          {/* Transcript Toggle Button */}
          {userRole === 'clinician' && sessionStatus === 'connected' && (
            <button
              onClick={() => setShowTranscript(!showTranscript)}
              className="p-2 bg-white bg-opacity-20 hover:bg-opacity-30 backdrop-blur-sm rounded-xl border border-white border-opacity-30 transition-all"
              title="Toggle Transcript"
            >
              <FileText className="w-5 h-5" />
            </button>
          )}

          {/* Status Badge */}
          <span className={`px-5 py-2 rounded-full text-sm font-bold shadow-lg ${
            sessionStatus === 'connected' ? 'bg-green-500 animate-pulse border-2 border-green-300' :
            sessionStatus === 'connecting' ? 'bg-yellow-500 border-2 border-yellow-300' :
            sessionStatus === 'reconnecting' ? 'bg-orange-500 animate-pulse border-2 border-orange-300' :
            'bg-gray-500 border-2 border-gray-300'
          }`}>
            {sessionStatus === 'connected' ? '‚óè Live' :
             sessionStatus === 'connecting' ? '‚óã Connecting...' :
             sessionStatus === 'reconnecting' ? '‚óã Reconnecting...' :
             '‚óã Loading...'}
          </span>
        </div>
      </div>

      {/* Main Video Area */}
      <div className="flex-1 relative bg-gray-900 overflow-hidden">
        {/* Remote Video (Full Screen) */}
        <div className="absolute inset-0">
          <video
            ref={remoteVideoRef}
            className="w-full h-full object-cover"
            autoPlay
            playsInline
          />
          {sessionStatus === 'connecting' && (
            <div className="absolute inset-0 flex items-center justify-center bg-gradient-to-br from-gray-900 via-purple-900 to-indigo-900 bg-opacity-95">
              <div className="text-center text-white">
                <div className="animate-spin rounded-full h-20 w-20 border-4 border-purple-200 border-t-purple-600 mx-auto mb-4"></div>
                <p className="text-2xl font-semibold">Connecting...</p>
                <p className="text-sm opacity-75 mt-2">Please wait while we establish your connection</p>
              </div>
            </div>
          )}
          {sessionStatus === 'connected' && remoteParticipantCount === 0 && (
            <div className="absolute inset-0 flex items-center justify-center bg-gradient-to-br from-gray-900 via-purple-900 to-indigo-900 bg-opacity-95">
              <div className="text-center text-white">
                <div className="w-24 h-24 mx-auto mb-4 bg-gradient-to-br from-purple-500 to-indigo-500 rounded-full flex items-center justify-center">
                  <svg className="w-12 h-12" fill="currentColor" viewBox="0 0 20 20">
                    <path fillRule="evenodd" d="M10 9a3 3 0 100-6 3 3 0 000 6zm-7 9a7 7 0 1114 0H3z" clipRule="evenodd" />
                  </svg>
                </div>
                <p className="text-xl font-semibold">Waiting for other participant to join...</p>
              </div>
            </div>
          )}
        </div>

        {/* Self View (Picture-in-Picture) */}
        <div className="absolute top-4 right-4 w-64 h-48 bg-gray-900 rounded-xl shadow-2xl overflow-hidden border-4 border-white transform hover:scale-105 transition-transform">
          <video
            ref={localVideoRef}
            className="w-full h-full object-cover mirror"
            autoPlay
            playsInline
            muted
          />
          {isVideoOff && (
            <div className="absolute inset-0 flex items-center justify-center bg-gradient-to-br from-gray-800 to-gray-900">
              <div className="w-16 h-16 bg-gradient-to-br from-purple-500 to-indigo-500 rounded-full flex items-center justify-center">
                <svg className="w-8 h-8 text-white" fill="currentColor" viewBox="0 0 20 20">
                  <path fillRule="evenodd" d="M10 9a3 3 0 100-6 3 3 0 000 6zm-7 9a7 7 0 1114 0H3z" clipRule="evenodd" />
                </svg>
              </div>
            </div>
          )}
        </div>

        {/* Screen Share (if active) */}
        {isScreenSharing && (
          <div className="absolute bottom-32 left-4 right-4 h-64 bg-gray-900 rounded-xl shadow-2xl overflow-hidden border-4 border-purple-500">
            <video
              ref={screenShareRef}
              className="w-full h-full object-contain"
              autoPlay
              playsInline
            />
            <div className="absolute top-2 left-2 px-4 py-2 bg-gradient-to-r from-purple-600 to-indigo-600 text-white text-sm font-bold rounded-lg shadow-lg">
              üì∫ Screen Sharing
            </div>
          </div>
        )}

        {/* Participant Count */}
        {sessionStatus === 'connected' && (
          <div className="absolute bottom-32 left-4 px-4 py-2 bg-gradient-to-r from-gray-800 to-gray-900 bg-opacity-95 backdrop-blur-sm text-white rounded-xl flex items-center space-x-2 border border-gray-700 shadow-lg">
            <div className="w-8 h-8 bg-gradient-to-br from-purple-500 to-indigo-500 rounded-full flex items-center justify-center">
              <svg className="w-5 h-5" fill="currentColor" viewBox="0 0 20 20">
                <path d="M9 6a3 3 0 11-6 0 3 3 0 016 0zM17 6a3 3 0 11-6 0 3 3 0 016 0zM12.93 17c.046-.327.07-.66.07-1a6.97 6.97 0 00-1.5-4.33A5 5 0 0119 16v1h-6.07zM6 11a5 5 0 015 5v1H1v-1a5 5 0 015-5z" />
              </svg>
            </div>
            <span className="font-semibold">{remoteParticipantCount + 1} participant{remoteParticipantCount !== 0 ? 's' : ''}</span>
          </div>
        )}

        {/* Transcription Panel */}
        {showTranscript && sessionStatus === 'connected' && sessionData?.id && (
          <div className="absolute top-4 left-4 w-96 h-[calc(100vh-200px)] z-30">
            <TranscriptionPanel sessionId={sessionData.id} />
          </div>
        )}
      </div>

      {/* Video Controls */}
      <VideoControls
        room={room}
        localAudioTrack={localAudioTrackRef.current}
        localVideoTrack={localVideoTrackRef.current}
        sessionId={sessionData?.id}
        clientName={clientName}
        emergencyContact={emergencyContact}
        onEndCall={handleEndSession}
        onStartRecording={handleStartRecording}
        onStopRecording={handleStopRecording}
        isRecording={isRecording}
        userRole={userRole}
        onToggleMute={handleToggleMute}
        onToggleVideo={handleToggleVideo}
        onToggleScreenShare={handleToggleScreenShare}
        onEmergencyActivated={handleEmergencyActivated}
      />
    </div>
  );
}
